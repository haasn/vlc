/*****************************************************************************
 * SSimSuperRes by Shiandow, adapted for mpv by igv
 *****************************************************************************
 * Copyright (C) 2016 Shiandow
 * Copyright (C) 2020 igv
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 3.0 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.
 *****************************************************************************/

#include <stddef.h>
#include "shaders.h"

const char ssim_super_res[] =
"// SSimSuperRes by Shiandow\n"
"//\n"
"// This library is free software; you can redistribute it and/or\n"
"// modify it under the terms of the GNU Lesser General Public\n"
"// License as published by the Free Software Foundation; either\n"
"// version 3.0 of the License, or (at your option) any later version.\n"
"// \n"
"// This library is distributed in the hope that it will be useful,\n"
"// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"// Lesser General Public License for more details.\n"
"// \n"
"// You should have received a copy of the GNU Lesser General Public\n"
"// License along with this library.\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!SAVE LOWRES\n"
"//!WIDTH NATIVE_CROPPED.w\n"
"//!WHEN NATIVE_CROPPED.w OUTPUT.w <\n"
"//!COMPONENTS 4\n"
"//!DESC SSSR Downscaling I\n"
"\n"
"#define axis 0\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define MN(B,C,x)   (x < 1.0 ? ((2.-1.5*B-(C))*x + (-3.+2.*B+C))*x*x + (1.-(B)/3.) : (((-(B)/6.-(C))*x + (B+5.*C))*x + (-2.*B-8.*C))*x+((4./3.)*B+4.*C))\n"
"#define Kernel(x)   MN(0.334, 0.333, abs(x))\n"
"#define taps        2.0\n"
"\n"
"#define Kb 0.0722\n"
"#define Kr 0.2126\n"
"#define Luma(rgb)   ( dot(vec3(Kr, 1.0 - Kr - Kb, Kb), pow(abs(rgb), vec3(2.0))) )\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = ceil((HOOKED_pos - taps/input_size) * HOOKED_size - offset - 0.5)[axis];\n"
"    float high = floor((HOOKED_pos + taps/input_size) * HOOKED_size - offset - 0.5)[axis];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"    vec2 pos = HOOKED_pos;\n"
"    vec4 tex;\n"
"\n"
"    for (float k = low; k <= high; k++) {\n"
"        pos[axis] = HOOKED_pt[axis] * (k - offset[axis] + 0.5);\n"
"        float rel = (pos[axis] - HOOKED_pos[axis])*input_size[axis];\n"
"        float w = Kernel(rel);\n"
"\n"
"        tex.rgb = textureLod(HOOKED_raw, pos, 0.0).rgb * HOOKED_mul;\n"
"        tex.a = Luma(tex.rgb);\n"
"        avg += w * tex;\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return vec4(avg.rgb, abs(avg.a - Luma(avg.rgb)));\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND LOWRES\n"
"//!SAVE LOWRES\n"
"//!WIDTH NATIVE_CROPPED.w\n"
"//!HEIGHT NATIVE_CROPPED.h\n"
"//!WHEN NATIVE_CROPPED.h OUTPUT.h <\n"
"//!COMPONENTS 4\n"
"//!DESC SSSR Downscaling II\n"
"\n"
"#define axis 1\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define MN(B,C,x)   (x < 1.0 ? ((2.-1.5*B-(C))*x + (-3.+2.*B+C))*x*x + (1.-(B)/3.) : (((-(B)/6.-(C))*x + (B+5.*C))*x + (-2.*B-8.*C))*x+((4./3.)*B+4.*C))\n"
"#define Kernel(x)   MN(0.334, 0.333, abs(x))\n"
"#define taps        2.0\n"
"\n"
"#define Kb 0.0722\n"
"#define Kr 0.2126\n"
"#define Luma(rgb)   ( dot(vec3(Kr, 1.0 - Kr - Kb, Kb), pow(abs(rgb), vec3(2.0))) )\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = ceil((LOWRES_pos - taps/input_size) * LOWRES_size - offset - 0.5)[axis];\n"
"    float high = floor((LOWRES_pos + taps/input_size) * LOWRES_size - offset - 0.5)[axis];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"    vec2 pos = LOWRES_pos;\n"
"    vec4 tex;\n"
"\n"
"    for (float k = low; k <= high; k++) {\n"
"        pos[axis] = LOWRES_pt[axis] * (k - offset[axis] + 0.5);\n"
"        float rel = (pos[axis] - LOWRES_pos[axis])*input_size[axis];\n"
"        float w = Kernel(rel);\n"
"\n"
"        tex.rgb = textureLod(LOWRES_raw, pos, 0.0).rgb * LOWRES_mul;\n"
"        tex.a = Luma(tex.rgb);\n"
"        avg += w * tex;\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return vec4(avg.rgb, abs(avg.a - Luma(avg.rgb)) + LOWRES_texOff(0).a);\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND PREKERNEL\n"
"//!SAVE varL\n"
"//!WIDTH NATIVE_CROPPED.w\n"
"//!HEIGHT NATIVE_CROPPED.h\n"
"//!WHEN NATIVE_CROPPED.w OUTPUT.w <\n"
"//!COMPONENTS 4\n"
"//!DESC SSSR varL\n"
"\n"
"#define spread      1.0 / 1000.0\n"
"\n"
"#define sqr(x)      pow(x, 2.0)\n"
"#define GetL(x,y)   PREKERNEL_tex(PREKERNEL_pt*(PREKERNEL_pos * input_size + tex_offset + vec2(x,y))).rgb\n"
"\n"
"#define Gamma(x)    ( pow(clamp(x, 0.0, 1.0), vec3(1.0/2.0)) )\n"
"#define Kb 0.0722\n"
"#define Kr 0.2126\n"
"#define Luma(rgb)   ( dot(vec3(Kr, 1.0 - Kr - Kb, Kb), pow(abs(rgb), vec3(2.0))) )\n"
"\n"
"vec4 hook() {\n"
"    vec3 meanL = vec3(0);\n"
"    for (int X=-1; X<=1; X++)\n"
"    for (int Y=-1; Y<=1; Y++) {\n"
"        meanL += GetL(X,Y) * pow(spread, sqr(float(X)) + sqr(float(Y)));\n"
"    }\n"
"    meanL /= (1.0 + 4.0*spread + 4.0*spread*spread);\n"
"\n"
"    float varL = 0.0;\n"
"    for (int X=-1; X<=1; X++)\n"
"    for (int Y=-1; Y<=1; Y++) {\n"
"        varL += Luma(GetL(X,Y) - meanL) * pow(spread, sqr(float(X)) + sqr(float(Y)));\n"
"    }\n"
"    varL /= (spread + 4.0*spread + 4.0*spread*spread);\n"
"\n"
"    return vec4(GetL(0,0), varL);\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND LOWRES\n"
"//!SAVE varH\n"
"//!WIDTH NATIVE_CROPPED.w\n"
"//!HEIGHT NATIVE_CROPPED.h\n"
"//!WHEN NATIVE_CROPPED.w OUTPUT.w <\n"
"//!COMPONENTS 1\n"
"//!DESC SSSR varH\n"
"\n"
"#define spread      1.0 / 1000.0\n"
"\n"
"#define sqr(x)      pow(x, 2.0)\n"
"#define GetH(x,y)   LOWRES_texOff(vec2(x,y)).rgb\n"
"\n"
"#define Gamma(x)    ( pow(clamp(x, 0.0, 1.0), vec3(1.0/2.0)) )\n"
"#define Kb 0.0722\n"
"#define Kr 0.2126\n"
"#define Luma(rgb)   ( dot(vec3(Kr, 1.0 - Kr - Kb, Kb), pow(abs(rgb), vec3(2.0))) )\n"
"\n"
"vec4 hook() {\n"
"    vec3 meanH = vec3(0);\n"
"    for (int X=-1; X<=1; X++)\n"
"    for (int Y=-1; Y<=1; Y++) {\n"
"        meanH += GetH(X,Y) * pow(spread, sqr(float(X)) + sqr(float(Y)));\n"
"    }\n"
"    meanH /= (1.0 + 4.0*spread + 4.0*spread*spread);\n"
"\n"
"    float varH = 0.0;\n"
"    for (int X=-1; X<=1; X++)\n"
"    for (int Y=-1; Y<=1; Y++) {\n"
"        varH += Luma(GetH(X,Y) - meanH) * pow(spread, sqr(float(X)) + sqr(float(Y)));\n"
"    }\n"
"    varH /= (spread + 4.0*spread + 4.0*spread*spread);\n"
"\n"
"    return vec4(varH, 0, 0, 0);\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!BIND LOWRES\n"
"//!BIND varL\n"
"//!BIND varH\n"
"//!WHEN NATIVE_CROPPED.w OUTPUT.w <\n"
"//!DESC SSSR final pass\n"
"\n"
"// -- Window Size --\n"
"#define taps        3.0\n"
"#define even        (taps - 2.0 * floor(taps / 2.0) == 0.0)\n"
"#define minX        int(1.0-ceil(taps/2.0))\n"
"#define maxX        int(floor(taps/2.0))\n"
"\n"
"#define factor      (LOWRES_pt*HOOKED_size)\n"
"#define Kernel(x)   (cos(acos(-1.0)*(x)/taps)) // Hann kernel\n"
"\n"
"#define sqr(x)      dot(x,x)\n"
"\n"
"// -- Input processing --\n"
"#define L(x,y)      ( varL_tex(varL_pt*(pos+vec2(x,y)+0.5)) )\n"
"#define H(x,y)      ( varH_tex(varH_pt*(pos+vec2(x,y)+0.5)) )\n"
"#define Lowres(x,y) ( LOWRES_tex(LOWRES_pt*(pos+vec2(x,y)+0.5)) )\n"
"\n"
"#define Gamma(x)    ( pow(clamp(x, 0.0, 1.0), vec3(1.0/2.0)) )\n"
"#define GammaInv(x) ( pow(clamp(x, 0.0, 1.0), vec3(2.0)) )\n"
"#define Kb 0.0722\n"
"#define Kr 0.2126\n"
"#define Luma(rgb)   ( dot(vec3(Kr, 1.0 - Kr - Kb, Kb), pow(abs(rgb), vec3(2.0))) )\n"
"\n"
"vec4 hook() {\n"
"    vec4 c0 = HOOKED_tex(HOOKED_pos);\n"
"\n"
"    // Calculate position\n"
"    vec2 pos = HOOKED_pos * LOWRES_size - vec2(0.5);\n"
"    vec2 offset = pos - (even ? floor(pos) : round(pos));\n"
"    pos -= offset;\n"
"\n"
"    vec2 mVar = vec2(0.0);\n"
"    for (int X=-1; X<=1; X++)\n"
"    for (int Y=-1; Y<=1; Y++) {\n"
"        vec2 w = clamp(1.5 - abs(vec2(X,Y) - offset), 0.0, 1.0);\n"
"        mVar += w.r * w.g * vec2(Lowres(X,Y).a, 1.0);\n"
"    }\n"
"    mVar.r /= mVar.g;\n"
"\n"
"    // Calculate faithfulness force\n"
"    float weightSum = 0.0;\n"
"    vec3 diff = vec3(0);\n"
"\n"
"    for (int X = minX; X <= maxX; X++)\n"
"    for (int Y = minX; Y <= maxX; Y++)\n"
"    {\n"
"        float varL = L(X,Y).a;\n"
"        float varH = H(X,Y).r;\n"
"        float R = -sqrt((varL + sqr(0.5/255.0)) / (varH + mVar.r + sqr(0.5/255.0)));\n"
"\n"
"        vec2 krnl = Kernel(vec2(X,Y) - offset);\n"
"        float weight = krnl.r * krnl.g / (Luma(c0.rgb - Lowres(X,Y).rgb) + Lowres(X,Y).a + sqr(0.5/255.0));\n"
"\n"
"        diff += weight * (L(X,Y).rgb + Lowres(X,Y).rgb * R + (-1.0 - R) * (c0.rgb));\n"
"        weightSum += weight;\n"
"    }\n"
"    diff /= weightSum;\n"
"\n"
"    c0.rgb = ((c0.rgb) + diff);\n"
"\n"
"    return c0;\n"
"}\n"
"";

const size_t ssim_super_res_len = sizeof(ssim_super_res) - 1;
