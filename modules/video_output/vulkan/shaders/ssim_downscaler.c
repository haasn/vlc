/*****************************************************************************
 * SSimDownscaler by Shiandow, adapted for mpv by igv
 *****************************************************************************
 * Copyright (C) 2017 Shiandow
 * Copyright (C) 2020 igv
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 3.0 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.
 *****************************************************************************/

#include <stddef.h>
#include "shaders.h"

const char ssim_downscaler[] =
"// SSimDownscaler by Shiandow\n"
"//\n"
"// This library is free software; you can redistribute it and/or\n"
"// modify it under the terms of the GNU Lesser General Public\n"
"// License as published by the Free Software Foundation; either\n"
"// version 3.0 of the License, or (at your option) any later version.\n"
"// \n"
"// This library is distributed in the hope that it will be useful,\n"
"// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
"// Lesser General Public License for more details.\n"
"// \n"
"// You should have received a copy of the GNU Lesser General Public\n"
"// License along with this library.\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!BIND PREKERNEL\n"
"//!SAVE L2\n"
"//!HEIGHT NATIVE_CROPPED.h\n"
"//!WHEN NATIVE_CROPPED.w POSTKERNEL.w >\n"
"//!COMPONENTS 3\n"
"//!DESC SSimDownscaler calc L2 pass 1\n"
"\n"
"#define factor      ((input_size*POSTKERNEL_pt)[axis])\n"
"\n"
"#define axis 0\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define MN(B,C,x)   (x <= 1.0 ? ((2.-1.5*B-C)*x + (-3.+2.*B+C))*x*x + (1.-B/3.) : (((-B/6.-C)*x + (B+5.*C))*x + (-2.*B-8.*C))*x+((4./3.)*B+4.*C))\n"
"#define Kernel(x)   MN(1.0/3.0, 1.0/3.0, abs(x))\n"
"#define taps        2.0\n"
"\n"
"vec4 hook() {\n"
"    vec2 base = PREKERNEL_pt * (PREKERNEL_pos * input_size + tex_offset);\n"
"\n"
"    // Calculate bounds\n"
"    float low  = floor((PREKERNEL_pos - taps*POSTKERNEL_pt) * input_size - offset + tex_offset + 0.5)[axis];\n"
"    float high = floor((PREKERNEL_pos + taps*POSTKERNEL_pt) * input_size - offset + tex_offset + 0.5)[axis];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"    vec2 pos = base;\n"
"\n"
"    for (float k = 0.0; k < high - low; k++) {\n"
"        pos[axis] = PREKERNEL_pt[axis] * (k + low + 0.5);\n"
"        float rel = (pos[axis] - base[axis])*POSTKERNEL_size[axis] + offset[axis]*factor;\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * pow(clamp(textureLod(PREKERNEL_raw, pos, 0.0) * PREKERNEL_mul, 0.0, 1.0), vec4(2.0));\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!BIND L2\n"
"//!SAVE L2\n"
"//!WHEN NATIVE_CROPPED.h POSTKERNEL.h >\n"
"//!COMPONENTS 3\n"
"//!DESC SSimDownscaler calc L2 pass 2\n"
"\n"
"#define factor      ((L2_size*POSTKERNEL_pt)[axis])\n"
"\n"
"#define axis 1\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define MN(B,C,x)   (x <= 1.0 ? ((2.-1.5*B-C)*x + (-3.+2.*B+C))*x*x + (1.-B/3.) : (((-B/6.-C)*x + (B+5.*C))*x + (-2.*B-8.*C))*x+((4./3.)*B+4.*C))\n"
"#define Kernel(x)   MN(1.0/3.0, 1.0/3.0, abs(x))\n"
"#define taps        2.0\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = floor((L2_pos - taps*POSTKERNEL_pt) * L2_size - offset + 0.5)[axis];\n"
"    float high = floor((L2_pos + taps*POSTKERNEL_pt) * L2_size - offset + 0.5)[axis];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"    vec2 pos = L2_pos;\n"
"\n"
"    for (float k = 0.0; k < high - low; k++) {\n"
"        pos[axis] = L2_pt[axis] * (k + low + 0.5);\n"
"        float rel = (pos[axis] - L2_pos[axis])*POSTKERNEL_size[axis] + offset[axis]*factor;\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * textureLod(L2_raw, pos, 0.0) * L2_mul;\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!SAVE M\n"
"//!WHEN NATIVE_CROPPED.w POSTKERNEL.w >\n"
"//!COMPONENTS 3\n"
"//!DESC SSimDownscaler calc Mean\n"
"\n"
"#define locality    8.0\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define Kernel(x)   pow(1.0 / locality, abs(x))\n"
"#define taps        3.0\n"
"#define maxtaps     taps\n"
"\n"
"vec4 ScaleH(vec2 pos) {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[0];\n"
"    float high = floor(+0.5*maxtaps - offset)[0];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[0] = POSTKERNEL_pos[0] + POSTKERNEL_pt[0] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[0];\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * clamp(POSTKERNEL_tex(pos), 0.0, 1.0);\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[1];\n"
"    float high = floor(+0.5*maxtaps - offset)[1];\n"
"\n"
"    float W = 0.0;\n"
"    vec4 avg = vec4(0);\n"
"    vec2 pos = POSTKERNEL_pos;\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[1] = POSTKERNEL_pos[1] + POSTKERNEL_pt[1] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[1];\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * ScaleH(pos);\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!BIND L2\n"
"//!BIND M\n"
"//!SAVE R\n"
"//!WHEN NATIVE_CROPPED.w POSTKERNEL.w >\n"
"//!COMPONENTS 3\n"
"//!DESC SSimDownscaler calc R\n"
"\n"
"#define locality    8.0\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define Kernel(x)   pow(1.0 / locality, abs(x))\n"
"#define taps        3.0\n"
"#define maxtaps     taps\n"
"\n"
"mat2x4 ScaleH(vec2 pos) {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[0];\n"
"    float high = floor(+0.5*maxtaps - offset)[0];\n"
"\n"
"    float W = 0.0;\n"
"    mat2x4 avg = mat2x4(0);\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[0] = L2_pos[0] + L2_pt[0] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[0];\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * mat2x4(pow(clamp(POSTKERNEL_tex(pos), 0.0, 1.0), vec4(2.0)), L2_tex(pos));\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[1];\n"
"    float high = floor(+0.5*maxtaps - offset)[1];\n"
"\n"
"    float W = 0.0;\n"
"    mat2x4 avg = mat2x4(0);\n"
"    vec2 pos = L2_pos;\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[1] = L2_pos[1] + L2_pt[1] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[1];\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * ScaleH(pos);\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    vec3 Sl = abs(avg[0].rgb - pow(M_texOff(0).rgb, vec3(2.0)));\n"
"    vec3 Sh = abs(avg[1].rgb - pow(M_texOff(0).rgb, vec3(2.0)));\n"
"    return vec4(mix(vec3(0.5), 1.0 / (1.0 + sqrt(Sh / Sl)), lessThan(vec3(5e-6), Sl)), 0.0);\n"
"}\n"
"\n"
"//!HOOK POSTKERNEL\n"
"//!BIND HOOKED\n"
"//!BIND M\n"
"//!BIND R\n"
"//!WHEN NATIVE_CROPPED.w POSTKERNEL.w >\n"
"//!DESC SSimDownscaler final pass\n"
"\n"
"#define locality    8.0\n"
"\n"
"#define offset      vec2(0,0)\n"
"\n"
"#define Kernel(x)   pow(1.0 / locality, abs(x))\n"
"#define taps        3.0\n"
"#define maxtaps     taps\n"
"\n"
"#define Gamma(x)    ( pow(x, vec3(1.0/2.0)) )\n"
"#define GammaInv(x) ( pow(clamp(x, 0.0, 1.0), vec3(2.0)) )\n"
"\n"
"mat3x3 ScaleH(vec2 pos) {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[0];\n"
"    float high = floor(+0.5*maxtaps - offset)[0];\n"
"\n"
"    float W = 0.0;\n"
"    mat3x3 avg = mat3x3(0);\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[0] = POSTKERNEL_pos[0] + POSTKERNEL_pt[0] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[0];\n"
"        float w = Kernel(rel);\n"
"        vec3 M = Gamma(M_tex(pos).rgb);\n"
"        vec3 R = R_tex(pos).rgb;\n"
"        R = 1.0 / R - 1.0;\n"
"        avg += w * mat3x3(R*M, M, R);\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"\n"
"    return avg;\n"
"}\n"
"\n"
"vec4 hook() {\n"
"    // Calculate bounds\n"
"    float low  = floor(-0.5*maxtaps - offset)[1];\n"
"    float high = floor(+0.5*maxtaps - offset)[1];\n"
"\n"
"    float W = 0.0;\n"
"    mat3x3 avg = mat3x3(0);\n"
"    vec2 pos = POSTKERNEL_pos;\n"
"\n"
"    for (float k = 0.0; k < maxtaps; k++) {\n"
"        pos[1] = POSTKERNEL_pos[1] + POSTKERNEL_pt[1] * (k + low + 1.0);\n"
"        float rel = (k + low + 1.0) + offset[1];\n"
"        float w = Kernel(rel);\n"
"\n"
"        avg += w * ScaleH(pos);\n"
"        W += w;\n"
"    }\n"
"    avg /= W;\n"
"    vec4 L = clamp(POSTKERNEL_texOff(0), 0.0, 1.0);\n"
"    return vec4(GammaInv(avg[1] + avg[2] * Gamma(L.rgb) - avg[0]), L.w);\n"
"}\n"
"";

const size_t ssim_downscaler_len = sizeof(ssim_downscaler) - 1;
